{"ast":null,"code":"// Angular imports\nimport 'reflect-metadata';\nimport { StoreServiceImplDev } from '../../services/store.service.impl.dev';\nimport { StoreServiceImplProd } from '../../services/store.service.impl.prod';\nimport { EnviromentUtil, RuntimeEnviroment } from '../../utils/enviroment.util';\n/**\n *  Loads value from Chrome settings storage, or sets default value if provided\n *  or common backup scenario  for given type.\n *  Sends value into Chrome settings storage if value is changed.\n*/\nexport const Setting = params => (target, propertyKey) => {\n  // should run only 1st time during class init, after that \n  // all annotated values should not be undefined\n  console.log('define property do pice kurva');\n  console.log(target);\n  console.log(Object.keys(target));\n  console.log(propertyKey);\n  console.log(Object(target));\n  console.log(Object(target)[propertyKey]);\n  //console.log(window);\n  console.log(\"-------------------\");\n  //SettingDecorator.getInstance().loadValue(target, propertyKey, (params === undefined) ? {} : params);\n};\n\nclass SettingDecorator {\n  constructor(storeService) {\n    SettingDecorator.storeService = storeService;\n  }\n  static getInstance() {\n    // must be solved that shitty way, because standart dependency injection comes too late\n    if (this.instance === undefined) {\n      this.instance = new SettingDecorator(EnviromentUtil.runningAt() === RuntimeEnviroment.WEB ? new StoreServiceImplDev() : new StoreServiceImplProd());\n    }\n    return this.instance;\n  }\n  loadValue(target, propertyKey, params) {\n    SettingDecorator.defineProperty(target, propertyKey);\n    let settingKey = params['storeKey'] === undefined ? target.constructor.name + \"-\" + propertyKey : params['storeKey'];\n    SettingDecorator.storeService.load(settingKey).then(resolve => {\n      // undefined should be edge case\n      console.log(\"setting resolved: \");\n      console.log(resolve);\n      //return resolve[settingKey];\n      return resolve;\n    }).catch(error => {\n      // communication error or not found in store should be that case\n      console.log(\"setting resolve error: \");\n      console.log(error);\n      return undefined;\n    }).then(result => {\n      console.log(\"setting resolve final stage: \");\n      console.log(result);\n      let fieldValue;\n      // value was found in settings store\n      if (result !== undefined) {\n        // console.log(propertyKey);\n        // console.log(params);\n        // if (SettingDecorator.hasParam(params, 'converter') \n        //         && params['converter']['storeConversion'] !== undefined\n        //         && params['converter']['storeConversion'](result) !== undefined) {\n        //     console.log(\"final strage conversion\");\n        //     fieldValue = params['converter']['storeConversion'](result);\n        // } else {\n        //     fieldValue = result;\n        // }\n      }\n      // value was not found in settings store but default one exists\n      else if (SettingDecorator.hasParam(params, 'defaultValue')) {\n        console.log(\"Setting resolve final stage: using default vals\");\n        fieldValue = params['defaultValue'];\n      }\n      // no value and no default one, try to set one for most common types\n      else {\n        console.log(\"Setting resolve final stage: try setting common default\");\n        fieldValue = SettingDecorator.getCommonDefaultValue(target, propertyKey);\n      }\n      // \"decorate\" fields, replace field value by value from settings store \n      // or send updated value to settings store\n      let currentValue = Object(target)[propertyKey];\n      let uploadAllowed = !(SettingDecorator.hasParam(params, 'onlyDownload') && params['onlyDownload'] === true);\n      console.log(\"uploadAllowed\");\n      console.log(uploadAllowed);\n      console.log(target);\n      console.log(propertyKey);\n      // Object.defineProperty(target, propertyKey, {\n      //     get: function() {\n      //         console.log('define property: get');\n      //         return currentValue === undefined ? fieldValue : currentValue;\n      //     },\n      //     set: function(value) {\n      //         console.log('define property: set');\n      //         if (currentValue != value) {\n      //             currentValue = value;\n      //             if (uploadAllowed) {\n      //                 let valueToUpload : any;\n      //                 //TODO refucktor\n      //                 if (SettingDecorator.hasParam(params, 'converter') \n      //                         && params['converter']['modelConversion'] !== undefined\n      //                         && params['converter']['modelConversion'](value) !== undefined) {\n      //                     valueToUpload = params['converter']['modelConversion'](value);\n      //                 } else {\n      //                     valueToUpload = value;\n      //                 }\n      //                 // console.log(\"value to upload\");\n      //                 // console.log(valueToUpload);\n      //                 SettingDecorator.storeService.save(settingKey, valueToUpload);\n      //             }\n      //         }\n      //     },\n      //     configurable: true\n      // })\n      // console.log(\"value finally used: \");\n      // console.log(propertyKey);\n      // console.log(params);\n      // console.log(Object(target)[propertyKey]); // mylo by sspustit tento mock\n    }).catch(error => {\n      console.log(error);\n    });\n  }\n  static getCommonDefaultValue(target, propertyKey) {\n    let fieldType = Reflect.getMetadata(\"design:type\", target, propertyKey).name;\n    switch (fieldType) {\n      case 'Boolean':\n        return false;\n      default:\n        return null;\n    }\n  }\n  static hasParam(params, paramName) {\n    return params !== undefined && Object(params)[paramName] !== undefined;\n  }\n  static defineProperty(target, propertyKey) {\n    console.log('define property do pice kurva');\n    console.log(target);\n    console.log(propertyKey);\n    console.log(Object(target));\n    console.log(Object(target)[propertyKey]);\n    let currentValue = Object(target)[propertyKey];\n    // let uploadAllowed : boolean = !(SettingDecorator.hasParam(params, 'onlyDownload') && params['onlyDownload'] === true);\n    console.log(currentValue);\n    Object.defineProperty(target, propertyKey, {\n      get: function () {\n        console.log('define property: get');\n        // return currentValue === undefined ? fieldValue : currentValue;\n        return currentValue === undefined ? null : currentValue;\n      },\n      set: function (value) {\n        console.log('define property: set');\n        if (currentValue != value) {\n          currentValue = value;\n          // if (uploadAllowed) {\n          //     let valueToUpload : any;\n          //     //TODO refucktor\n          //     // if (SettingDecorator.hasParam(params, 'converter') \n          //     //         && params['converter']['modelConversion'] !== undefined\n          //     //         && params['converter']['modelConversion'](value) !== undefined) {\n          //     //     valueToUpload = params['converter']['modelConversion'](value);\n          //     // } else {\n          //     //     valueToUpload = value;\n          //     // }\n          //     // console.log(\"value to upload\");\n          //     // console.log(valueToUpload);\n          //    // SettingDecorator.storeService.save(settingKey, valueToUpload);\n          // }\n        }\n      },\n\n      configurable: true\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}