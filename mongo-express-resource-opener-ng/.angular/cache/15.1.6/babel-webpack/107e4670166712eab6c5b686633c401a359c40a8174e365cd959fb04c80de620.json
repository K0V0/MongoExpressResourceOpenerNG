{"ast":null,"code":"// Angular imports\nimport 'reflect-metadata';\n// My imports\nimport { StoreService } from './../services/store.service';\n/**\n *  Loads value from Chrome settings storage, or sets default value if provided\n *  or common backup scenario  for given type.\n *  Sends value into Chrome settings storage if value is changed.\n*/\nexport const Setting = params => (target, propertyKey) => {\n  // should run only 1st time during class init, after that \n  // all annotated values should not be undefined\n  SettingDecorator.getInstance().loadValue(target, propertyKey, params);\n};\nclass SettingDecorator {\n  constructor(storeService) {\n    SettingDecorator.storeService = storeService;\n  }\n  static getInstance() {\n    // must be solved that shitty way, because standart dependency injection comes too late\n    if (this.instance === undefined) {\n      this.instance = new SettingDecorator(new StoreService());\n    }\n    return this.instance;\n  }\n  loadValue(target, propertyKey, params) {\n    let settingKey = SettingDecorator.hasParam(params, 'storeKey') ? params['storeKey'] : target.constructor.name + \"-\" + propertyKey;\n    SettingDecorator.storeService.load(settingKey).then(resolve => {\n      // undefined should be edge case\n      return resolve[settingKey];\n    }).catch(error => {\n      // communication error or not found in store should be that case\n      return undefined;\n    }).then(result => {\n      let fieldValue;\n      // value was found in settings store\n      if (result !== undefined) {\n        console.log(propertyKey);\n        console.log(params);\n        if (SettingDecorator.hasParam(params, 'converter') && params['converter']['storeConversion'] !== undefined) {\n          fieldValue = params['converter']['storeConversion'](result);\n        } else {\n          fieldValue = result;\n        }\n      }\n      // value was not found in settings store but default one exists\n      else if (SettingDecorator.hasParam(params, 'defaultValue')) {\n        fieldValue = params['defaultValue'];\n      }\n      // no value and no default one, try to set one for most common types\n      else {\n        fieldValue = SettingDecorator.getCommonDefaultValue(target, propertyKey);\n      }\n      // \"decorate\" fields, replace field value by value from settings store \n      // or send updated value to settings store\n      let currentValue = Object(target)[propertyKey];\n      let uploadAllowed = !(SettingDecorator.hasParam(params, 'onlyDownload') && params['onlyDownload'] === true);\n      console.log(\"uploadAllowed\");\n      console.log(uploadAllowed);\n      Object.defineProperty(target, propertyKey, {\n        get: function () {\n          return currentValue === undefined ? fieldValue : currentValue;\n        },\n        set: function (value) {\n          if (currentValue != value) {\n            currentValue = value;\n            if (uploadAllowed) {\n              let valueToUpload;\n              if (SettingDecorator.hasParam(params, 'converter') && params['converter']['modelConversion'] !== undefined) {\n                valueToUpload = params['converter']['modelConversion'](value);\n              } else {\n                valueToUpload = value;\n              }\n              console.log(\"value to upload\");\n              console.log(valueToUpload);\n              SettingDecorator.storeService.save(settingKey, valueToUpload);\n            }\n          }\n        },\n        configurable: true\n      });\n      console.log(\"value finally used: \");\n      console.log(propertyKey);\n      console.log(params);\n      console.log(Object(target)[propertyKey]); // mylo by sspustit tento mock\n    });\n  }\n\n  static getCommonDefaultValue(target, propertyKey) {\n    let fieldType = Reflect.getMetadata(\"design:type\", target, propertyKey).name;\n    switch (fieldType) {\n      case 'Boolean':\n        return false;\n      default:\n        return null;\n    }\n  }\n  static hasParam(params, paramName) {\n    return params !== undefined && Object(params)[paramName] !== undefined;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}