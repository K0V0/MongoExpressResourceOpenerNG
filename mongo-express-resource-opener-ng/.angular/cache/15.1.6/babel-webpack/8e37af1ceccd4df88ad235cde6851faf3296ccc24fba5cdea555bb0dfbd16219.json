{"ast":null,"code":"// Angular imports\nimport 'reflect-metadata';\nimport { StoreServiceImplDev } from '../../services/store.service.impl.dev';\nimport { StoreServiceImplProd } from '../../services/store.service.impl.prod';\nimport { EnviromentUtil, RuntimeEnviroment } from '../../utils/enviroment.util';\n/**\n *  Loads value from Chrome settings storage, or sets default value if provided\n *  or common backup scenario  for given type.\n *  Sends value into Chrome settings storage if value is changed.\n*/\nexport const Setting = params => (target, propertyKey) => {\n  // should run only 1st time during class init, after that all annotated values should not be undefined\n  SettingDecorator.getInstance().loadValue(target, propertyKey, params === undefined ? {} : params);\n};\nclass SettingDecorator {\n  constructor(storeService) {\n    SettingDecorator.storeService = storeService;\n  }\n  static getInstance() {\n    // must be solved that shitty way, because standart dependency injection comes too late\n    if (this.instance === undefined) {\n      this.instance = new SettingDecorator(EnviromentUtil.runningAt() === RuntimeEnviroment.WEB ? new StoreServiceImplDev() : new StoreServiceImplProd());\n    }\n    return this.instance;\n  }\n  loadValue(target, propertyKey, params) {\n    let settingKey = params['storeKey'] === undefined ? target.constructor.name + \"-\" + propertyKey : params['storeKey'];\n    SettingDecorator.storeService.load(settingKey).then(resolve => {\n      // undefined should be edge case\n      return resolve;\n    }).catch(error => {\n      // communication error or not found in store should be that case\n      return undefined;\n    }).then(result => {\n      let fieldValue;\n      if (result !== undefined && result !== null) {\n        // value was found in settings store\n        fieldValue = SettingDecorator.getOrConvertedValue(result, params, 'storeConversion');\n      } else if (SettingDecorator.hasParam(params, 'defaultValue')) {\n        // value was not found in settings store but default one exists\n        fieldValue = params['defaultValue'];\n      } else {\n        // no value and no default one, try to set one for most common types\n        fieldValue = SettingDecorator.getCommonDefaultValue(target, propertyKey);\n      }\n      //FIXME this works only for primitive types, changing a property of object does not trigger set\n      // \"decorate\" fields, replace field value by value from settings store or send updated value to settings store\n      let currentValue = Object(target)[propertyKey];\n      let uploadAllowed = !(SettingDecorator.hasParam(params, 'onlyDownload') && params['onlyDownload'] === true);\n      this.definePropertiesRecursive(target, propertyKey);\n      // Object.defineProperty(target, propertyKey, {\n      //     get: function() {\n      //         return (currentValue === undefined || currentValue === null) ? fieldValue : currentValue;\n      //     },\n      //     set: function(value) {\n      //         if (currentValue != value) {\n      //             currentValue = value;\n      //             if (uploadAllowed) {\n      //                 SettingDecorator.storeService.save(\n      //                     settingKey, \n      //                     SettingDecorator.getOrConvertedValue(value, params, 'modelConversion'));\n      //             }\n      //         }\n      //     },\n      //     configurable: true\n      // })\n      // callback function\n      params['afterExec']?.apply(this, currentValue === undefined || currentValue === null ? fieldValue : currentValue);\n    }).catch(error => {\n      console.log(error);\n    });\n  }\n  definePropertiesRecursive(obj, descriptor) {\n    Object.getOwnPropertyNames(obj).forEach(prop => {\n      const value = obj[prop];\n      if (typeof value === 'object' && value !== null) {\n        this.definePropertiesRecursive(value, descriptor);\n      }\n      Object.defineProperty(obj, prop, descriptor);\n    });\n  }\n  // private recursive(obj : any) {\n  //     for (var property in obj) {\n  //         if (obj.hasOwnProperty(property)) {\n  //             if (typeof obj[property] == \"object\") {\n  //                 this.recursive(obj[property]);\n  //             } else {\n  //                 console.log(property + \" = \" + obj[property]);\n  //                 Object.defineProperty(obj, property, {\n  //                     get: function() {\n  //                         console.log(\"GET\")\n  //                         //return (currentValue === undefined || currentValue === null) ? fieldValue : currentValue;\n  //                     },\n  //                     set: function(value) {\n  //                         console.log(\"SET\");\n  //                         // if (currentValue != value) {\n  //                         //     currentValue = value;\n  //                         //     if (uploadAllowed) {\n  //                         //         SettingDecorator.storeService.save(\n  //                         //             settingKey, \n  //                         //             SettingDecorator.getOrConvertedValue(value, params, 'modelConversion'));\n  //                         //     }\n  //                         // }\n  //                     },\n  //                     configurable: true\n  //                 })\n  //             }\n  //         }\n  //     }\n  // }\n  static getCommonDefaultValue(target, propertyKey) {\n    let fieldType = Reflect.getMetadata(\"design:type\", target, propertyKey).name;\n    switch (fieldType) {\n      case 'Boolean':\n        return false;\n      default:\n        return null;\n    }\n  }\n  static getOrConvertedValue(valueToConvert, params, converterType) {\n    let converters = params['converter'];\n    if (converters === undefined) {\n      return valueToConvert;\n    }\n    let converter = Object(converters)[converterType];\n    if (converter === undefined) {\n      return valueToConvert;\n    }\n    return converter(valueToConvert);\n  }\n  static hasParam(params, ...paramNames) {\n    let tmp = params;\n    for (let i = 0; i < paramNames.length; i++) {\n      tmp = tmp[paramNames[i]];\n      if (tmp === undefined) {\n        return false;\n      }\n    }\n    return true;\n  }\n}","map":{"version":3,"mappings":"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","names":["StoreServiceImplDev","StoreServiceImplProd","EnviromentUtil","RuntimeEnviroment","Setting","params","target","propertyKey","SettingDecorator","getInstance","loadValue","undefined","constructor","storeService","instance","runningAt","WEB","settingKey","name","load","then","resolve","catch","error","result","fieldValue","getOrConvertedValue","hasParam","getCommonDefaultValue","currentValue","Object","uploadAllowed","definePropertiesRecursive","apply","console","log","obj","descriptor","getOwnPropertyNames","forEach","prop","value","defineProperty","fieldType","Reflect","getMetadata","valueToConvert","converterType","converters","converter","paramNames","tmp","i","length"],"sourceRoot":"","sources":["/home/kovo/Documents/PROJEKTY GitHub/MongoExpressResourceOpenerNG/mongo-express-resource-opener-ng/src/app/_base/decorators/setting/setting.decorator.ts"],"sourcesContent":["// Angular imports\nimport 'reflect-metadata';\n\n// My imports\nimport { StoreService } from '../../services/store.service';\nimport { StoreServiceImplDev } from '../../services/store.service.impl.dev';\nimport { StoreServiceImplProd } from '../../services/store.service.impl.prod';\nimport { EnviromentUtil, RuntimeEnviroment } from '../../utils/enviroment.util';\nimport { SettingDecoratorParameters } from './setting.decorator.parameters';\nimport { SettingDecoratorConverter } from './setting.decorator.converter';\nimport { BaseComponent } from 'src/app/_base/components/_base/base.component';\n\n\n/**\n *  Loads value from Chrome settings storage, or sets default value if provided \n *  or common backup scenario  for given type.\n *  Sends value into Chrome settings storage if value is changed.\n*/\nexport const Setting = <TYP>(params ?: SettingDecoratorParameters) => <TYP>(target: BaseComponent, propertyKey: string) => {\n    // should run only 1st time during class init, after that all annotated values should not be undefined\n    SettingDecorator.getInstance().loadValue<TYP>(target, propertyKey, (params === undefined) ? {} : params);\n}\n\n\nclass SettingDecorator {\n\n    private static instance : SettingDecorator;\n\n    private static storeService : StoreService;\n\n    private constructor(storeService : StoreService) {\n        SettingDecorator.storeService = storeService;\n    }\n\n    public static getInstance() : SettingDecorator {\n        // must be solved that shitty way, because standart dependency injection comes too late\n        if (this.instance === undefined) {\n            this.instance = new SettingDecorator(\n                EnviromentUtil.runningAt() === RuntimeEnviroment.WEB ? new StoreServiceImplDev() : new StoreServiceImplProd()\n            )\n        }\n        return this.instance;\n    }\n\n    public loadValue<TYP>(target : Object, propertyKey : string, params : SettingDecoratorParameters) : void {\n\n        let settingKey : string = params['storeKey'] === undefined\n            ? target.constructor.name + \"-\" + propertyKey \n            : params['storeKey']\n\n        SettingDecorator.storeService\n            .load(settingKey)\n            .then((resolve : any) => {\n                // undefined should be edge case\n                return resolve;\n            })\n            .catch((error : any) => {\n                // communication error or not found in store should be that case\n                return undefined;\n            })\n            .then((result : any) => {\n\n                let fieldValue : TYP;\n                if (result !== undefined && result !== null) {\n                    // value was found in settings store\n                    fieldValue  = SettingDecorator.getOrConvertedValue(result, params, 'storeConversion');\n                } else if (SettingDecorator.hasParam(params, 'defaultValue')) {\n                    // value was not found in settings store but default one exists\n                    fieldValue = params['defaultValue'];\n                } else {\n                    // no value and no default one, try to set one for most common types\n                    fieldValue = SettingDecorator.getCommonDefaultValue(target, propertyKey);\n                }\n\n                //FIXME this works only for primitive types, changing a property of object does not trigger set\n                // \"decorate\" fields, replace field value by value from settings store or send updated value to settings store\n                let currentValue : TYP = Object(target)[propertyKey];\n\n\n                let uploadAllowed : boolean = !(SettingDecorator.hasParam(params, 'onlyDownload') && params['onlyDownload'] === true);\n\n                this.definePropertiesRecursive(target, propertyKey);\n\n                // Object.defineProperty(target, propertyKey, {\n                //     get: function() {\n                //         return (currentValue === undefined || currentValue === null) ? fieldValue : currentValue;\n                //     },\n                //     set: function(value) {\n                //         if (currentValue != value) {\n                //             currentValue = value;\n                //             if (uploadAllowed) {\n                //                 SettingDecorator.storeService.save(\n                //                     settingKey, \n                //                     SettingDecorator.getOrConvertedValue(value, params, 'modelConversion'));\n                //             }\n                //         }\n                //     },\n                //     configurable: true\n                // })\n\n                // callback function\n                params['afterExec']?.apply(this, (currentValue === undefined || currentValue === null) ? fieldValue : currentValue);\n            })\n            .catch((error : any) => {\n                console.log(error);\n            }); \n\n    }\n\n    private definePropertiesRecursive(obj : any, descriptor : string) {\n        Object.getOwnPropertyNames(obj).forEach((prop) => {\n          const value = obj[prop];\n          if (typeof value === 'object' && value !== null) {\n            this.definePropertiesRecursive(value, descriptor);\n          }\n          Object.defineProperty(obj, prop, descriptor);\n        });\n      }\n\n    // private recursive(obj : any) {\n    //     for (var property in obj) {\n    //         if (obj.hasOwnProperty(property)) {\n    //             if (typeof obj[property] == \"object\") {\n    //                 this.recursive(obj[property]);\n    //             } else {\n    //                 console.log(property + \" = \" + obj[property]);\n\n    //                 Object.defineProperty(obj, property, {\n    //                     get: function() {\n    //                         console.log(\"GET\")\n    //                         //return (currentValue === undefined || currentValue === null) ? fieldValue : currentValue;\n    //                     },\n    //                     set: function(value) {\n    //                         console.log(\"SET\");\n    //                         // if (currentValue != value) {\n    //                         //     currentValue = value;\n    //                         //     if (uploadAllowed) {\n    //                         //         SettingDecorator.storeService.save(\n    //                         //             settingKey, \n    //                         //             SettingDecorator.getOrConvertedValue(value, params, 'modelConversion'));\n    //                         //     }\n    //                         // }\n    //                     },\n    //                     configurable: true\n    //                 })\n\n    //             }\n    //         }\n    //     }\n    // }\n\n    private static getCommonDefaultValue(target : Object, propertyKey : string) : any {\n        let fieldType : string = Reflect.getMetadata(\"design:type\", target, propertyKey).name;\n        switch(fieldType) {\n            case 'Boolean':\n                return false;\n            default:\n                return null; \n        }\n    }\n\n    private static getOrConvertedValue(valueToConvert : any, params : SettingDecoratorParameters, converterType : string) : any {\n        let converters : SettingDecoratorConverter<any, any> | undefined = params['converter'];\n        if (converters === undefined) {\n            return valueToConvert;\n        }\n        let converter : Function = Object(converters)[converterType];\n        if (converter === undefined) {\n            return valueToConvert;\n        }\n        return converter(valueToConvert);\n    }\n\n    private static hasParam(params: SettingDecoratorParameters, ...paramNames : string[]) : boolean {\n        let tmp : any = params;\n        for (let i=0; i<paramNames.length; i++) {\n            tmp = tmp[paramNames[i]];\n            if (tmp === undefined) {\n                return false;\n            } \n        }\n        return true;\n    }\n    \n}"]},"metadata":{},"sourceType":"module","externalDependencies":[]}