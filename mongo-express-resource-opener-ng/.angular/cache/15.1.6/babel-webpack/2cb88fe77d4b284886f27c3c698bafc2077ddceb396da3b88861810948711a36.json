{"ast":null,"code":"import _defineProperty from \"/home/matej/Dokumenty/PROJEKTY GitHub/MongoExpressResourceOpenerNG/mongo-express-resource-opener-ng/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n// Angular imports\nimport 'reflect-metadata';\nimport { StoreServiceImplDev } from '../../services/store.service.impl.dev';\nimport { StoreServiceImplProd } from '../../services/store.service.impl.prod';\nimport { EnviromentUtil, RuntimeEnviroment } from '../../utils/enviroment.util';\n/**\n *  Loads value from Chrome settings storage, or sets default value if provided\n *  or common backup scenario  for given type.\n *  Sends value into Chrome settings storage if value is changed.\n*/\nexport const Setting = params => (target, propertyKey) => {\n  // should run only 1st time during class init, after that \n  // all annotated values should not be undefined\n  console.log('define property do pice kurva');\n  console.log(target);\n  console.log(Object.keys(target));\n  console.log(propertyKey);\n  console.log(Object(target));\n  console.log(Object(target)[propertyKey]);\n  //console.log(window);\n  console.log(\"-------------------\");\n  //SettingDecorator.getInstance().loadValue(target, propertyKey, (params === undefined) ? {} : params);\n};\n\nclass SettingDecorator {\n  constructor(storeService) {\n    SettingDecorator.storeService = storeService;\n  }\n  static getInstance() {\n    // must be solved that shitty way, because standart dependency injection comes too late\n    if (this.instance === undefined) {\n      this.instance = new SettingDecorator(EnviromentUtil.runningAt() === RuntimeEnviroment.WEB ? new StoreServiceImplDev() : new StoreServiceImplProd());\n    }\n    return this.instance;\n  }\n  loadValue(target, propertyKey, params) {\n    SettingDecorator.defineProperty(target, propertyKey);\n    let settingKey = params['storeKey'] === undefined ? target.constructor.name + \"-\" + propertyKey : params['storeKey'];\n    SettingDecorator.storeService.load(settingKey).then(resolve => {\n      // undefined should be edge case\n      console.log(\"setting resolved: \");\n      console.log(resolve);\n      //return resolve[settingKey];\n      return resolve;\n    }).catch(error => {\n      // communication error or not found in store should be that case\n      console.log(\"setting resolve error: \");\n      console.log(error);\n      return undefined;\n    }).then(result => {\n      console.log(\"setting resolve final stage: \");\n      console.log(result);\n      let fieldValue;\n      // value was found in settings store\n      if (result !== undefined) {\n        // console.log(propertyKey);\n        // console.log(params);\n        // if (SettingDecorator.hasParam(params, 'converter') \n        //         && params['converter']['storeConversion'] !== undefined\n        //         && params['converter']['storeConversion'](result) !== undefined) {\n        //     console.log(\"final strage conversion\");\n        //     fieldValue = params['converter']['storeConversion'](result);\n        // } else {\n        //     fieldValue = result;\n        // }\n      }\n      // value was not found in settings store but default one exists\n      else if (SettingDecorator.hasParam(params, 'defaultValue')) {\n        console.log(\"Setting resolve final stage: using default vals\");\n        fieldValue = params['defaultValue'];\n      }\n      // no value and no default one, try to set one for most common types\n      else {\n        console.log(\"Setting resolve final stage: try setting common default\");\n        fieldValue = SettingDecorator.getCommonDefaultValue(target, propertyKey);\n      }\n      // \"decorate\" fields, replace field value by value from settings store \n      // or send updated value to settings store\n      let currentValue = Object(target)[propertyKey];\n      let uploadAllowed = !(SettingDecorator.hasParam(params, 'onlyDownload') && params['onlyDownload'] === true);\n      console.log(\"uploadAllowed\");\n      console.log(uploadAllowed);\n      console.log(target);\n      console.log(propertyKey);\n      // Object.defineProperty(target, propertyKey, {\n      //     get: function() {\n      //         console.log('define property: get');\n      //         return currentValue === undefined ? fieldValue : currentValue;\n      //     },\n      //     set: function(value) {\n      //         console.log('define property: set');\n      //         if (currentValue != value) {\n      //             currentValue = value;\n      //             if (uploadAllowed) {\n      //                 let valueToUpload : any;\n      //                 //TODO refucktor\n      //                 if (SettingDecorator.hasParam(params, 'converter') \n      //                         && params['converter']['modelConversion'] !== undefined\n      //                         && params['converter']['modelConversion'](value) !== undefined) {\n      //                     valueToUpload = params['converter']['modelConversion'](value);\n      //                 } else {\n      //                     valueToUpload = value;\n      //                 }\n      //                 // console.log(\"value to upload\");\n      //                 // console.log(valueToUpload);\n      //                 SettingDecorator.storeService.save(settingKey, valueToUpload);\n      //             }\n      //         }\n      //     },\n      //     configurable: true\n      // })\n      // console.log(\"value finally used: \");\n      // console.log(propertyKey);\n      // console.log(params);\n      // console.log(Object(target)[propertyKey]); // mylo by sspustit tento mock\n    }).catch(error => {\n      console.log(error);\n    });\n  }\n  static getCommonDefaultValue(target, propertyKey) {\n    let fieldType = Reflect.getMetadata(\"design:type\", target, propertyKey).name;\n    switch (fieldType) {\n      case 'Boolean':\n        return false;\n      default:\n        return null;\n    }\n  }\n  static hasParam(params, paramName) {\n    return params !== undefined && Object(params)[paramName] !== undefined;\n  }\n  static defineProperty(target, propertyKey) {\n    console.log('define property do pice kurva');\n    console.log(target);\n    console.log(propertyKey);\n    console.log(Object(target));\n    console.log(Object(target)[propertyKey]);\n    let currentValue = Object(target)[propertyKey];\n    // let uploadAllowed : boolean = !(SettingDecorator.hasParam(params, 'onlyDownload') && params['onlyDownload'] === true);\n    console.log(currentValue);\n    Object.defineProperty(target, propertyKey, {\n      get: function () {\n        console.log('define property: get');\n        // return currentValue === undefined ? fieldValue : currentValue;\n        return currentValue === undefined ? null : currentValue;\n      },\n      set: function (value) {\n        console.log('define property: set');\n        if (currentValue != value) {\n          currentValue = value;\n          // if (uploadAllowed) {\n          //     let valueToUpload : any;\n          //     //TODO refucktor\n          //     // if (SettingDecorator.hasParam(params, 'converter') \n          //     //         && params['converter']['modelConversion'] !== undefined\n          //     //         && params['converter']['modelConversion'](value) !== undefined) {\n          //     //     valueToUpload = params['converter']['modelConversion'](value);\n          //     // } else {\n          //     //     valueToUpload = value;\n          //     // }\n          //     // console.log(\"value to upload\");\n          //     // console.log(valueToUpload);\n          //    // SettingDecorator.storeService.save(settingKey, valueToUpload);\n          // }\n        }\n      },\n\n      configurable: true\n    });\n  }\n}\n_defineProperty(SettingDecorator, \"instance\", void 0);\n_defineProperty(SettingDecorator, \"storeService\", void 0);","map":{"version":3,"mappings":"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","names":["StoreServiceImplDev","StoreServiceImplProd","EnviromentUtil","RuntimeEnviroment","Setting","params","target","propertyKey","console","log","Object","keys","SettingDecorator","constructor","storeService","getInstance","instance","undefined","runningAt","WEB","loadValue","defineProperty","settingKey","name","load","then","resolve","catch","error","result","fieldValue","hasParam","getCommonDefaultValue","currentValue","uploadAllowed","fieldType","Reflect","getMetadata","paramName","get","set","value","configurable"],"sourceRoot":"","sources":["/home/matej/Dokumenty/PROJEKTY GitHub/MongoExpressResourceOpenerNG/mongo-express-resource-opener-ng/src/app/_base/decorators/setting/setting.decorator.ts"],"sourcesContent":["// Angular imports\nimport 'reflect-metadata';\n\n// My imports\nimport { StoreService } from '../../services/store.service';\nimport { StoreServiceImplDev } from '../../services/store.service.impl.dev';\nimport { StoreServiceImplProd } from '../../services/store.service.impl.prod';\nimport { EnviromentUtil, RuntimeEnviroment } from '../../utils/enviroment.util';\nimport { SettingDecoratorParameters } from './setting.decorator.parameters';\n\n\n/**\n *  Loads value from Chrome settings storage, or sets default value if provided \n *  or common backup scenario  for given type.\n *  Sends value into Chrome settings storage if value is changed.\n*/\nexport const Setting = (params ?: SettingDecoratorParameters) => (target: any, propertyKey: string) => {\n    // should run only 1st time during class init, after that \n    // all annotated values should not be undefined\n\n    console.log('define property do pice kurva');\n    console.log(target);\n    console.log(Object.keys(target));\n    console.log(propertyKey);\n    console.log(Object(target));\n    console.log(Object(target)[propertyKey]);\n    //console.log(window);\n\n    console.log(\"-------------------\");\n    \n\n    //SettingDecorator.getInstance().loadValue(target, propertyKey, (params === undefined) ? {} : params);\n}\n\n\nclass SettingDecorator {\n\n    private static instance : SettingDecorator;\n\n    private static storeService : StoreService;\n\n    private constructor(storeService : StoreService) {\n        SettingDecorator.storeService = storeService;\n    }\n\n    public static getInstance() : SettingDecorator {\n        // must be solved that shitty way, because standart dependency injection comes too late\n        if (this.instance === undefined) {\n            this.instance = new SettingDecorator(\n                EnviromentUtil.runningAt() === RuntimeEnviroment.WEB ? new StoreServiceImplDev() : new StoreServiceImplProd()\n            )\n        }\n        return this.instance;\n    }\n\n    public loadValue(target : any, propertyKey : string, params : SettingDecoratorParameters) : void {\n\n        SettingDecorator.defineProperty(target, propertyKey);    \n\n        let settingKey : string = params['storeKey'] === undefined\n            ? target.constructor.name + \"-\" + propertyKey \n            : params['storeKey']\n\n        SettingDecorator.storeService\n            .load(settingKey)\n            .then((resolve : any) => {\n                // undefined should be edge case\n                console.log(\"setting resolved: \");\n                console.log(resolve);\n                //return resolve[settingKey];\n                return resolve;\n            })\n            .catch((error : any) => {\n                // communication error or not found in store should be that case\n                console.log(\"setting resolve error: \");\n                console.log(error);\n                return undefined;\n            })\n            .then((result : any) => {\n\n                console.log(\"setting resolve final stage: \");\n                console.log(result);\n\n                let fieldValue : any;\n                // value was found in settings store\n                if (result !== undefined) {\n                    // console.log(propertyKey);\n                    // console.log(params);\n                    // if (SettingDecorator.hasParam(params, 'converter') \n                    //         && params['converter']['storeConversion'] !== undefined\n                    //         && params['converter']['storeConversion'](result) !== undefined) {\n                    //     console.log(\"final strage conversion\");\n                    //     fieldValue = params['converter']['storeConversion'](result);\n                    // } else {\n                    //     fieldValue = result;\n                    // }\n                }\n                // value was not found in settings store but default one exists\n                else if (SettingDecorator.hasParam(params, 'defaultValue')) {\n                    console.log(\"Setting resolve final stage: using default vals\");\n                    fieldValue = params['defaultValue'];\n                }\n                // no value and no default one, try to set one for most common types\n                else {\n                    console.log(\"Setting resolve final stage: try setting common default\");\n                    fieldValue = SettingDecorator.getCommonDefaultValue(target, propertyKey);\n                }\n\n                // \"decorate\" fields, replace field value by value from settings store \n                // or send updated value to settings store\n                let currentValue : any = Object(target)[propertyKey];\n                let uploadAllowed : boolean = !(SettingDecorator.hasParam(params, 'onlyDownload') && params['onlyDownload'] === true);\n\n                console.log(\"uploadAllowed\");\n                console.log(uploadAllowed);\n\n                console.log(target);\n                console.log(propertyKey);\n                \n                // Object.defineProperty(target, propertyKey, {\n                //     get: function() {\n                //         console.log('define property: get');\n                //         return currentValue === undefined ? fieldValue : currentValue;\n                //     },\n                //     set: function(value) {\n                //         console.log('define property: set');\n                //         if (currentValue != value) {\n                //             currentValue = value;\n                //             if (uploadAllowed) {\n                //                 let valueToUpload : any;\n                //                 //TODO refucktor\n                //                 if (SettingDecorator.hasParam(params, 'converter') \n                //                         && params['converter']['modelConversion'] !== undefined\n                //                         && params['converter']['modelConversion'](value) !== undefined) {\n                //                     valueToUpload = params['converter']['modelConversion'](value);\n                //                 } else {\n                //                     valueToUpload = value;\n                //                 }\n                //                 // console.log(\"value to upload\");\n                //                 // console.log(valueToUpload);\n                //                 SettingDecorator.storeService.save(settingKey, valueToUpload);\n                //             }\n                //         }\n                //     },\n                //     configurable: true\n                // })\n\n                // console.log(\"value finally used: \");\n                // console.log(propertyKey);\n                // console.log(params);\n                // console.log(Object(target)[propertyKey]); // mylo by sspustit tento mock\n\n            })\n            .catch((error : any) => {\n                console.log(error);\n            }); \n\n    }\n\n    private static getCommonDefaultValue(target : Object, propertyKey : string) : any {\n        let fieldType : string = Reflect.getMetadata(\"design:type\", target, propertyKey).name;\n        switch(fieldType) {\n            case 'Boolean':\n                return false;\n            default:\n                return null; \n        }\n    }\n\n    private static hasParam(params: SettingDecoratorParameters, paramName : string) : boolean {\n        return params !== undefined && Object(params)[paramName] !== undefined;\n    }\n\n    private static defineProperty(target : any, propertyKey : string) : void {\n        console.log('define property do pice kurva');\n        console.log(target);\n        console.log(propertyKey);\n        console.log(Object(target));\n        console.log( Object(target)[propertyKey]);\n    \n        let currentValue : any = Object(target)[propertyKey];\n        // let uploadAllowed : boolean = !(SettingDecorator.hasParam(params, 'onlyDownload') && params['onlyDownload'] === true);\n\n        console.log(currentValue);\n\n        Object.defineProperty(target, propertyKey, {\n                    get: function() {\n                        console.log('define property: get');\n                        // return currentValue === undefined ? fieldValue : currentValue;\n                        return currentValue === undefined ? null : currentValue;\n                    },\n                    set: function(value) {\n                        console.log('define property: set');\n                        if (currentValue != value) {\n                            currentValue = value;\n                            // if (uploadAllowed) {\n                            //     let valueToUpload : any;\n                            //     //TODO refucktor\n                            //     // if (SettingDecorator.hasParam(params, 'converter') \n                            //     //         && params['converter']['modelConversion'] !== undefined\n                            //     //         && params['converter']['modelConversion'](value) !== undefined) {\n                            //     //     valueToUpload = params['converter']['modelConversion'](value);\n                            //     // } else {\n                            //     //     valueToUpload = value;\n                            //     // }\n                            //     // console.log(\"value to upload\");\n                            //     // console.log(valueToUpload);\n                            //    // SettingDecorator.storeService.save(settingKey, valueToUpload);\n                            // }\n                        }\n                    },\n                    configurable: true\n                })\n    }\n    \n}"]},"metadata":{},"sourceType":"module","externalDependencies":[]}