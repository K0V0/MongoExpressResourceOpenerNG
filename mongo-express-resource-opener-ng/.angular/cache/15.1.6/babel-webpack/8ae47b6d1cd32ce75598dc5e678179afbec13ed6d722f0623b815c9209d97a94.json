{"ast":null,"code":"export class Optional {\n  isEmpty() {\n    return !this.isPresent();\n  }\n  static of(value) {\n    if (value !== null && value !== undefined) return new PresentOptional(value);else throw new TypeError(\"The passed value was null or undefined.\");\n  }\n  static ofNonNull(value) {\n    return Optional.of(value);\n  }\n  static ofNullable(nullable) {\n    if (nullable !== null && nullable !== undefined) return new PresentOptional(nullable);else return new EmptyOptional();\n  }\n  static empty() {\n    return new EmptyOptional();\n  }\n  static from(option) {\n    switch (option.kind) {\n      case \"present\":\n        return Optional.of(option.value);\n      case \"empty\":\n        return Optional.empty();\n      default:\n        throw new TypeError(\"The passed value was not an Option type.\");\n    }\n  }\n}\nexport class PresentOptional extends Optional {\n  constructor(value) {\n    super();\n    this.payload = value;\n  }\n  isPresent() {\n    return true;\n  }\n  get() {\n    return this.payload;\n  }\n  ifPresent(consumer) {\n    consumer(this.payload);\n  }\n  ifPresentOrElse(consumer, emptyAction) {\n    consumer(this.payload);\n  }\n  filter(predicate) {\n    return predicate(this.payload) ? this : Optional.empty();\n  }\n  map(mapper) {\n    const result = mapper(this.payload);\n    return Optional.ofNullable(result);\n  }\n  flatMap(mapper) {\n    return mapper(this.payload);\n  }\n  or(supplier) {\n    return this;\n  }\n  orElse(another) {\n    return this.payload;\n  }\n  orElseGet(another) {\n    return this.payload;\n  }\n  orElseThrow(exception) {\n    return this.payload;\n  }\n  orNull() {\n    return this.payload;\n  }\n  orUndefined() {\n    return this.payload;\n  }\n  toOption() {\n    return {\n      kind: \"present\",\n      value: this.payload\n    };\n  }\n  matches(cases) {\n    return cases.present(this.payload);\n  }\n  toJSON(key) {\n    return this.payload;\n  }\n}\nexport class EmptyOptional extends Optional {\n  isPresent() {\n    return false;\n  }\n  constructor() {\n    super();\n  }\n  get() {\n    throw new TypeError(\"The optional is not present.\");\n  }\n  ifPresent(consumer) {}\n  ifPresentOrElse(consumer, emptyAction) {\n    emptyAction();\n  }\n  filter(predicate) {\n    return this;\n  }\n  map(mapper) {\n    return Optional.empty();\n  }\n  flatMap(mapper) {\n    return Optional.empty();\n  }\n  or(supplier) {\n    return supplier();\n  }\n  orElse(another) {\n    return another;\n  }\n  orElseGet(another) {\n    return this.orElse(another());\n  }\n  orElseThrow(exception) {\n    throw exception();\n  }\n  orNull() {\n    return null;\n  }\n  orUndefined() {\n    return undefined;\n  }\n  toOption() {\n    return {\n      kind: \"empty\"\n    };\n  }\n  matches(cases) {\n    return cases.empty();\n  }\n  toJSON(key) {\n    return null;\n  }\n}","map":{"version":3,"names":["Optional","isEmpty","isPresent","of","value","undefined","PresentOptional","TypeError","ofNonNull","ofNullable","nullable","EmptyOptional","empty","from","option","kind","constructor","payload","get","ifPresent","consumer","ifPresentOrElse","emptyAction","filter","predicate","map","mapper","result","flatMap","or","supplier","orElse","another","orElseGet","orElseThrow","exception","orNull","orUndefined","toOption","matches","cases","present","toJSON","key"],"sources":["/home/matej/Dokumenty/PROJEKTY GitHub/MongoExpressResourceOpenerNG/mongo-express-resource-opener-ng/node_modules/typescript-optional/dist/esm/optional.js"],"sourcesContent":["export class Optional {\n    isEmpty() {\n        return !this.isPresent();\n    }\n    static of(value) {\n        if (value !== null && value !== undefined)\n            return new PresentOptional(value);\n        else\n            throw new TypeError(\"The passed value was null or undefined.\");\n    }\n    static ofNonNull(value) {\n        return Optional.of(value);\n    }\n    static ofNullable(nullable) {\n        if (nullable !== null && nullable !== undefined)\n            return new PresentOptional(nullable);\n        else\n            return new EmptyOptional();\n    }\n    static empty() {\n        return new EmptyOptional();\n    }\n    static from(option) {\n        switch (option.kind) {\n            case \"present\": return Optional.of(option.value);\n            case \"empty\": return Optional.empty();\n            default: throw new TypeError(\"The passed value was not an Option type.\");\n        }\n    }\n}\nexport class PresentOptional extends Optional {\n    constructor(value) {\n        super();\n        this.payload = value;\n    }\n    isPresent() {\n        return true;\n    }\n    get() {\n        return this.payload;\n    }\n    ifPresent(consumer) {\n        consumer(this.payload);\n    }\n    ifPresentOrElse(consumer, emptyAction) {\n        consumer(this.payload);\n    }\n    filter(predicate) {\n        return (predicate(this.payload)) ? this : Optional.empty();\n    }\n    map(mapper) {\n        const result = mapper(this.payload);\n        return Optional.ofNullable(result);\n    }\n    flatMap(mapper) {\n        return mapper(this.payload);\n    }\n    or(supplier) {\n        return this;\n    }\n    orElse(another) {\n        return this.payload;\n    }\n    orElseGet(another) {\n        return this.payload;\n    }\n    orElseThrow(exception) {\n        return this.payload;\n    }\n    orNull() {\n        return this.payload;\n    }\n    orUndefined() {\n        return this.payload;\n    }\n    toOption() {\n        return { kind: \"present\", value: this.payload };\n    }\n    matches(cases) {\n        return cases.present(this.payload);\n    }\n    toJSON(key) {\n        return this.payload;\n    }\n}\nexport class EmptyOptional extends Optional {\n    isPresent() {\n        return false;\n    }\n    constructor() {\n        super();\n    }\n    get() {\n        throw new TypeError(\"The optional is not present.\");\n    }\n    ifPresent(consumer) {\n    }\n    ifPresentOrElse(consumer, emptyAction) {\n        emptyAction();\n    }\n    filter(predicate) {\n        return this;\n    }\n    map(mapper) {\n        return Optional.empty();\n    }\n    flatMap(mapper) {\n        return Optional.empty();\n    }\n    or(supplier) {\n        return supplier();\n    }\n    orElse(another) {\n        return another;\n    }\n    orElseGet(another) {\n        return this.orElse(another());\n    }\n    orElseThrow(exception) {\n        throw exception();\n    }\n    orNull() {\n        return null;\n    }\n    orUndefined() {\n        return undefined;\n    }\n    toOption() {\n        return { kind: \"empty\" };\n    }\n    matches(cases) {\n        return cases.empty();\n    }\n    toJSON(key) {\n        return null;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}