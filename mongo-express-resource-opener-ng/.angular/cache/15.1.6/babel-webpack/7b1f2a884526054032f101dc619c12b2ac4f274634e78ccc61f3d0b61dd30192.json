{"ast":null,"code":"import _defineProperty from \"/home/matej/Dokumenty/PROJEKTY GitHub/MongoExpressResourceOpenerNG/mongo-express-resource-opener-ng/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n// Angular imports\nimport 'reflect-metadata';\n// My imports\nimport { StoreService } from './../services/store.service';\n/**\n *  Loads value from Chrome settings storage, or sets default value if provided\n *  or common backup scenario  for given type.\n *  Sends value into Chrome settings storage if value is changed.\n*/\nexport const Setting = params => (target, propertyKey) => {\n  // should run only 1st time during class init, after that \n  // all annotated values should not be undefined\n  SettingDecorator.getInstance().loadValue(target, propertyKey, params);\n};\nclass SettingDecorator {\n  constructor(storeService) {\n    SettingDecorator.storeService = storeService;\n  }\n  static getInstance() {\n    // must be solved that shitty way, because standart dependency injection comes too late\n    if (this.instance === undefined) {\n      this.instance = new SettingDecorator(new StoreService());\n    }\n    return this.instance;\n  }\n  loadValue(target, propertyKey, params) {\n    let settingKey = SettingDecorator.hasParam(params, 'storeKey') ? params['storeKey'] : target.constructor.name + \"-\" + propertyKey;\n    SettingDecorator.storeService.load(settingKey).then(resolve => {\n      // undefined should be edge case\n      console.log(\"setting resolved: \");\n      console.log(resolve);\n      //return resolve[settingKey];\n    }).catch(error => {\n      // communication error or not found in store should be that case\n      console.log(\"setting resolve error: \");\n      console.log(error);\n      return undefined;\n    }).then(result => {\n      let fieldValue;\n      // value was found in settings store\n      if (result !== undefined) {\n        // console.log(propertyKey);\n        // console.log(params);\n        if (SettingDecorator.hasParam(params, 'converter') && params['converter']['storeConversion'] !== undefined) {\n          fieldValue = params['converter']['storeConversion'](result);\n        } else {\n          fieldValue = result;\n        }\n      }\n      // value was not found in settings store but default one exists\n      else if (SettingDecorator.hasParam(params, 'defaultValue')) {\n        fieldValue = params['defaultValue'];\n      }\n      // no value and no default one, try to set one for most common types\n      else {\n        fieldValue = SettingDecorator.getCommonDefaultValue(target, propertyKey);\n      }\n      // \"decorate\" fields, replace field value by value from settings store \n      // or send updated value to settings store\n      let currentValue = Object(target)[propertyKey];\n      let uploadAllowed = !(SettingDecorator.hasParam(params, 'onlyDownload') && params['onlyDownload'] === true);\n      // console.log(\"uploadAllowed\");\n      // console.log(uploadAllowed);\n      Object.defineProperty(target, propertyKey, {\n        get: function () {\n          return currentValue === undefined ? fieldValue : currentValue;\n        },\n        set: function (value) {\n          if (currentValue != value) {\n            currentValue = value;\n            if (uploadAllowed) {\n              let valueToUpload;\n              if (SettingDecorator.hasParam(params, 'converter') && params['converter']['modelConversion'] !== undefined) {\n                valueToUpload = params['converter']['modelConversion'](value);\n              } else {\n                valueToUpload = value;\n              }\n              // console.log(\"value to upload\");\n              // console.log(valueToUpload);\n              SettingDecorator.storeService.save(settingKey, valueToUpload);\n            }\n          }\n        },\n        configurable: true\n      });\n      // console.log(\"value finally used: \");\n      // console.log(propertyKey);\n      // console.log(params);\n      // console.log(Object(target)[propertyKey]); // mylo by sspustit tento mock\n    });\n  }\n\n  static getCommonDefaultValue(target, propertyKey) {\n    let fieldType = Reflect.getMetadata(\"design:type\", target, propertyKey).name;\n    switch (fieldType) {\n      case 'Boolean':\n        return false;\n      default:\n        return null;\n    }\n  }\n  static hasParam(params, paramName) {\n    return params !== undefined && Object(params)[paramName] !== undefined;\n  }\n}\n_defineProperty(SettingDecorator, \"instance\", void 0);\n_defineProperty(SettingDecorator, \"storeService\", void 0);","map":{"version":3,"mappings":"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","names":["StoreService","Setting","params","target","propertyKey","SettingDecorator","getInstance","loadValue","constructor","storeService","instance","undefined","settingKey","hasParam","name","load","then","resolve","console","log","catch","error","result","fieldValue","getCommonDefaultValue","currentValue","Object","uploadAllowed","defineProperty","get","set","value","valueToUpload","save","configurable","fieldType","Reflect","getMetadata","paramName"],"sourceRoot":"","sources":["/home/matej/Dokumenty/PROJEKTY GitHub/MongoExpressResourceOpenerNG/mongo-express-resource-opener-ng/src/app/_base/decorators/setting.decorator.ts"],"sourcesContent":["// Angular imports\nimport 'reflect-metadata';\n\n// My imports\nimport { StoreService } from './../services/store.service';\n\n\ninterface SettingDecoratorParameters {\n    // default value to use if no value in chrome store is found \n    defaultValue ?: any;\n    // allow passing \"undefined\" as default value (which is default value of unitialized property by default)\n    allowUndefined ?: boolean;\n    // TODO\n    // define own key under which is value stored in google chrome storage\n    // by default mechanism uses containing class and property name combination as key\n    storeKey ?: string;\n    // switch into uni-directional relationship with chrome store, value will be transfered from chrome store\n    // and set to property, but no other way round. By default, binding is bi-directional\n    onlyDownload ?: boolean;\n    // provide converter fullfiling SettingDecoratorConverter interface specification if You need your data \n    // have converted/modified when coming from/to chrome store\n    converter ?: SettingDecoratorConverter<any, any>\n}\n\nexport interface SettingDecoratorConverter<TYPE_IN_NG, TYPE_IN_STORE> {\n    // in implementing class, return null if You do not want conversion in some direction\n    // model -> settings store\n    modelConversion : (content : TYPE_IN_NG) => TYPE_IN_STORE; \n    // settings store -> model\n    storeConversion : (content : TYPE_IN_STORE) => TYPE_IN_NG;\n}\n\n\n/**\n *  Loads value from Chrome settings storage, or sets default value if provided \n *  or common backup scenario  for given type.\n *  Sends value into Chrome settings storage if value is changed.\n*/\nexport const Setting = (params ?: SettingDecoratorParameters) => (target: Object, propertyKey: string) => {\n    // should run only 1st time during class init, after that \n    // all annotated values should not be undefined\n    SettingDecorator.getInstance().loadValue(target, propertyKey, params);\n}\n\n\nclass SettingDecorator {\n\n    private static instance : SettingDecorator;\n\n    private static storeService : StoreService;\n\n    private constructor(storeService : StoreService) {\n        SettingDecorator.storeService = storeService;\n    }\n\n    public static getInstance() : SettingDecorator {\n        // must be solved that shitty way, because standart dependency injection comes too late\n        if (this.instance === undefined) {\n            this.instance = new SettingDecorator(\n                new StoreService()\n            )\n        }\n        return this.instance;\n    }\n\n    public loadValue(target : Object, propertyKey : string, params : any) : void {\n\n        let settingKey : string = SettingDecorator.hasParam(params, 'storeKey') \n            ? params['storeKey'] \n            : target.constructor.name + \"-\" + propertyKey;\n\n        SettingDecorator.storeService\n            .load(settingKey)\n            .then((resolve) => {\n                // undefined should be edge case\n                console.log(\"setting resolved: \");\n                console.log(resolve);\n                //return resolve[settingKey];\n            })\n            .catch((error) => {\n                // communication error or not found in store should be that case\n                console.log(\"setting resolve error: \");\n                console.log(error);\n                return undefined;\n            })\n            .then((result) => {\n\n                let fieldValue : any;\n                // value was found in settings store\n                if (result !== undefined) {\n                    // console.log(propertyKey);\n                    // console.log(params);\n                    if (SettingDecorator.hasParam(params, 'converter') && params['converter']['storeConversion'] !== undefined) {\n                        fieldValue = params['converter']['storeConversion'](result);\n                    } else {\n                        fieldValue = result;\n                    }\n                }\n                // value was not found in settings store but default one exists\n                else if (SettingDecorator.hasParam(params, 'defaultValue')) {\n                    fieldValue = params['defaultValue'];\n                }\n                // no value and no default one, try to set one for most common types\n                else {\n                    fieldValue = SettingDecorator.getCommonDefaultValue(target, propertyKey);\n                }\n\n                // \"decorate\" fields, replace field value by value from settings store \n                // or send updated value to settings store\n                let currentValue : any = Object(target)[propertyKey];\n                let uploadAllowed : boolean = !(SettingDecorator.hasParam(params, 'onlyDownload') && params['onlyDownload'] === true);\n\n                // console.log(\"uploadAllowed\");\n                // console.log(uploadAllowed);\n                \n                Object.defineProperty(target, propertyKey, {\n                    get: function() {\n                        return currentValue === undefined ? fieldValue : currentValue;\n                    },\n                    set: function(value) {\n                        if (currentValue != value) {\n                            currentValue = value;\n                            if (uploadAllowed) {\n                                let valueToUpload : any;\n                                if (SettingDecorator.hasParam(params, 'converter') && params['converter']['modelConversion'] !== undefined) {\n                                    valueToUpload = params['converter']['modelConversion'](value);\n                                } else {\n                                    valueToUpload = value;\n                                }\n                                // console.log(\"value to upload\");\n                                // console.log(valueToUpload);\n                                SettingDecorator.storeService.save(settingKey, valueToUpload);\n                            }\n                        }\n                    },\n                    configurable: true\n                })\n\n                // console.log(\"value finally used: \");\n                // console.log(propertyKey);\n                // console.log(params);\n                // console.log(Object(target)[propertyKey]); // mylo by sspustit tento mock\n\n            }); \n\n    }\n\n    private static getCommonDefaultValue(target : Object, propertyKey : string) : any {\n        let fieldType : string = Reflect.getMetadata(\"design:type\", target, propertyKey).name;\n        switch(fieldType) {\n            case 'Boolean':\n                return false;\n            default:\n                return null; \n        }\n    }\n\n    private static hasParam(params: SettingDecoratorParameters, paramName : string) : boolean {\n        return params !== undefined && Object(params)[paramName] !== undefined;\n    }\n    \n}"]},"metadata":{},"sourceType":"module","externalDependencies":[]}