{"ast":null,"code":"import _defineProperty from \"/home/matej/Dokumenty/PROJEKTY GitHub/MongoExpressResourceOpenerNG/mongo-express-resource-opener-ng/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n// Angular imports\nimport 'reflect-metadata';\n// My imports\nimport { EnviromentUtil, RuntimeEnviroment } from './../utils/enviroment.util';\nimport { StoreServiceImplProd } from '../services/store.service.impl.prod';\nimport { StoreServiceImplDev } from '../services/store.service.impl.dev';\nexport class SettingDecoratorConverterBase {\n  storeConversion(content) {\n    if (content === undefined) {\n      return undefined;\n    }\n    return this.mapForNgModel(content);\n  }\n  modelConversion(content) {\n    if (content === undefined) {\n      return undefined;\n    }\n    return this.mapForStore(content);\n  }\n}\n/**\n *  Loads value from Chrome settings storage, or sets default value if provided\n *  or common backup scenario  for given type.\n *  Sends value into Chrome settings storage if value is changed.\n*/\nexport const Setting = params => (target, propertyKey) => {\n  // should run only 1st time during class init, after that \n  // all annotated values should not be undefined\n  SettingDecorator.getInstance().loadValue(target, propertyKey, params);\n};\nlet SettingDecorator = /*#__PURE__*/(() => {\n  class SettingDecorator {\n    constructor(storeService) {\n      SettingDecorator.storeService = storeService;\n    }\n    static getInstance() {\n      // must be solved that shitty way, because standart dependency injection comes too late\n      if (this.instance === undefined) {\n        this.instance = new SettingDecorator(EnviromentUtil.runningAt() === RuntimeEnviroment.WEB ? new StoreServiceImplDev() : new StoreServiceImplProd());\n      }\n      return this.instance;\n    }\n    loadValue(target, propertyKey, params) {\n      let settingKey = SettingDecorator.hasParam(params, 'storeKey') ? params['storeKey'] : target.constructor.name + \"-\" + propertyKey;\n      SettingDecorator.storeService.load(settingKey).then(resolve => {\n        // undefined should be edge case\n        console.log(\"setting resolved: \");\n        console.log(resolve);\n        //return resolve[settingKey];\n        return resolve;\n      }).catch(error => {\n        // communication error or not found in store should be that case\n        console.log(\"setting resolve error: \");\n        console.log(error);\n        return undefined;\n      }).then(result => {\n        console.log(\"setting resolve final stage: \");\n        console.log(result);\n        let fieldValue;\n        // value was found in settings store\n        if (result !== undefined) {\n          // console.log(propertyKey);\n          // console.log(params);\n          if (SettingDecorator.hasParam(params, 'converter') && params['converter']['storeConversion'] !== undefined && params['converter']['storeConversion'](result) !== undefined) {\n            console.log(\"final strage conversion\");\n            fieldValue = params['converter']['storeConversion'](result);\n          } else {\n            fieldValue = result;\n          }\n        }\n        // value was not found in settings store but default one exists\n        else if (SettingDecorator.hasParam(params, 'defaultValue')) {\n          console.log(\"Setting resolve final stage: using default vals\");\n          fieldValue = params['defaultValue'];\n        }\n        // no value and no default one, try to set one for most common types\n        else {\n          console.log(\"Setting resolve final stage: try setting common default\");\n          fieldValue = SettingDecorator.getCommonDefaultValue(target, propertyKey);\n        }\n        // \"decorate\" fields, replace field value by value from settings store \n        // or send updated value to settings store\n        let currentValue = Object(target)[propertyKey];\n        let uploadAllowed = !(SettingDecorator.hasParam(params, 'onlyDownload') && params['onlyDownload'] === true);\n        // console.log(\"uploadAllowed\");\n        // console.log(uploadAllowed);\n        Object.defineProperty(target, propertyKey, {\n          get: function () {\n            // console.log('define property: get');\n            return currentValue === undefined ? fieldValue : currentValue;\n          },\n          set: function (value) {\n            // console.log('define property: set');\n            if (currentValue != value) {\n              currentValue = value;\n              if (uploadAllowed) {\n                let valueToUpload;\n                //TODO refucktor\n                if (SettingDecorator.hasParam(params, 'converter') && params['converter']['modelConversion'] !== undefined && params['converter']['modelConversion'](value) !== undefined) {\n                  valueToUpload = params['converter']['modelConversion'](value);\n                } else {\n                  valueToUpload = value;\n                }\n                // console.log(\"value to upload\");\n                // console.log(valueToUpload);\n                SettingDecorator.storeService.save(settingKey, valueToUpload);\n              }\n            }\n          },\n          configurable: true\n        });\n        // console.log(\"value finally used: \");\n        // console.log(propertyKey);\n        // console.log(params);\n        // console.log(Object(target)[propertyKey]); // mylo by sspustit tento mock\n      }).catch(error => {\n        console.log(error);\n      });\n    }\n    static getCommonDefaultValue(target, propertyKey) {\n      let fieldType = Reflect.getMetadata(\"design:type\", target, propertyKey).name;\n      switch (fieldType) {\n        case 'Boolean':\n          return false;\n        default:\n          return null;\n      }\n    }\n    static hasParam(params, paramName) {\n      return params !== undefined && Object(params)[paramName] !== undefined;\n    }\n  }\n  _defineProperty(SettingDecorator, \"instance\", void 0);\n  _defineProperty(SettingDecorator, \"storeService\", void 0);\n  return SettingDecorator;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}