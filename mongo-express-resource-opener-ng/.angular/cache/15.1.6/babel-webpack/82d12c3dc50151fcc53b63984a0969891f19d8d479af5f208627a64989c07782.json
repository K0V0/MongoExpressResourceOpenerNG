{"ast":null,"code":"import { EventsUtil } from './../../utils/events.util';\n// Angular imports\nimport 'reflect-metadata';\nimport { EnviromentUtil } from '../../utils/enviroment.util';\n/**\n *  Loads value from Chrome settings storage, or sets default value if provided\n *  or common backup scenario  for given type.\n *  Sends value into Chrome settings storage if value is changed.\n*/\nexport const Setting = params => (target, propertyKey) => {\n  // should run only 1st time during class init, after that all annotated values should not be undefined\n  SettingDecorator.getInstance().loadValue(target, propertyKey, params === undefined ? {} : params);\n};\nexport class SettingDecorator {\n  constructor(storeService) {\n    SettingDecorator.storeService = storeService;\n  }\n  static getInstance() {\n    // must be solved that shitty way, because standart dependency injection comes too late\n    if (this.instance === undefined) {\n      this.instance = new SettingDecorator(EnviromentUtil.getStoreService());\n    }\n    return this.instance;\n  }\n  loadValue(target, propertyKey, params) {\n    let settingKey = params['storeKey'] === undefined ? target.constructor.name + \"-\" + propertyKey : params['storeKey'];\n    SettingDecorator.storeService.load(settingKey).then(resolve => {\n      // undefined should be edge case\n      return resolve;\n    }).catch(error => {\n      // communication error or not found in store should be that case\n      return undefined;\n    }).then(result => {\n      let fieldValue;\n      if (result !== undefined && result !== null) {\n        // value was found in settings store\n        fieldValue = SettingDecorator.getOrConvertedValue(result, params, 'storeConversion');\n      } else if (SettingDecorator.hasParam(params, 'defaultValue')) {\n        // value was not found in settings store but default one exists\n        fieldValue = params['defaultValue'];\n      } else {\n        // no value and no default one, try to set one for most common types\n        fieldValue = SettingDecorator.getCommonDefaultValue(target, propertyKey);\n      }\n      //FIXME this works only for primitive types, changing a property of object does not trigger set\n      // \"decorate\" fields, replace field value by value from settings store or send updated value to settings store\n      let currentValue = Object(target)[propertyKey];\n      let uploadAllowed = !(SettingDecorator.hasParam(params, 'onlyDownload') && params['onlyDownload'] === true);\n      Object.defineProperty(target, propertyKey, {\n        get: function () {\n          return currentValue === undefined || currentValue === null ? fieldValue : currentValue;\n        },\n        set: function (value) {\n          if (currentValue != value) {\n            currentValue = value;\n            if (uploadAllowed) {\n              EventsUtil.getSettingsSavedEmiter().emit(true);\n              SettingDecorator.storeService.save(settingKey, SettingDecorator.getOrConvertedValue(value, params, 'modelConversion')).then(result => {\n                EventsUtil.getSettingsSavedEmiter().emit(false);\n              });\n              //TODO scenarions for unsucessfull settings save\n            }\n          }\n        },\n\n        configurable: true\n      });\n      // callback function\n      params['afterExec']?.apply(this, currentValue === undefined || currentValue === null ? fieldValue : currentValue);\n    }).catch(error => {\n      console.log(error);\n    });\n  }\n  static getCommonDefaultValue(target, propertyKey) {\n    let fieldType = Reflect.getMetadata(\"design:type\", target, propertyKey).name;\n    switch (fieldType) {\n      case 'Boolean':\n        return false;\n      default:\n        return null;\n    }\n  }\n  static getOrConvertedValue(valueToConvert, params, converterType) {\n    let converters = params['converter'];\n    if (converters === undefined) {\n      return valueToConvert;\n    }\n    let converter = Object(converters)[converterType];\n    if (converter === undefined) {\n      return valueToConvert;\n    }\n    return converter.call(converters, valueToConvert);\n  }\n  static hasParam(params, ...paramNames) {\n    let tmp = params;\n    for (let i = 0; i < paramNames.length; i++) {\n      tmp = tmp[paramNames[i]];\n      if (tmp === undefined) {\n        return false;\n      }\n    }\n    return true;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}